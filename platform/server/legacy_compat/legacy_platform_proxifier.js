import { EventEmitter } from 'events';

/**
 * List of the server events to be forwarded to the legacy platform.
 */
const ServerEventsToForward = [
  'listening',
  'error',
  'clientError',
  'connection',
];

/**
 * Represents "proxy" between legacy and current platform.
 *
 */
export class LegacyPlatformProxifier extends EventEmitter {
  /**
   * @type {Root}
   * @readonly
   * @private
   */
  _root;

  /**
   * @type {Map<string, function>}
   * @readonly
   * @private
   */
  _eventHandlers;

  /**
   * @type {Logger}
   * @readonly
   * @private
   */
  _log;

  /**
   * @type {Server|undefined}
   * @private
   */
  _server;

  constructor(root) {
    super();

    this._root = root;
    this._log = root.logger.get('legacy-platform-proxifier');

    // HapiJS expects that the following events will be generated by `listener`, see:
    // https://github.com/hapijs/hapi/blob/v14.2.0/lib/connection.js.
    this._eventHandlers = new Map(
      ServerEventsToForward.map(eventName => {
        return [
          eventName,
          (...args) => {
            this._log.debug(`Event is being forwarded: ${eventName}`);
            this.emit(eventName, ...args);
          },
        ];
      })
    );
  }

  /**
   * Neither new nor legacy platform should use this method directly.
   */
  address() {
    return this._server && this._server.address();
  }

  /**
   * Neither new nor legacy platform should use this method directly.
   * @param {number} port
   * @param {string} host
   * @param {function} [callback]
   */
  async listen(port, host, callback) {
    this._log.debug(`"listen" has been called (${host}:${port}).`);

    let error;
    try {
      await this._root.start();
    } catch (err) {
      error = err;
      this.emit('error', err);
    }

    if (callback !== undefined) {
      callback(error);
    }
  }

  /**
   * Neither new nor legacy platform should use this method directly.
   * @param {function} [callback]
   */
  async close(callback) {
    this._log.debug('"close" has been called.');

    let error;
    try {
      await this._root.shutdown();
    } catch (err) {
      error = err;
      this.emit('error', err);
    }

    if (callback !== undefined) {
      callback(error);
    }
  }

  /**
   * Neither new nor legacy platform should use this method directly.
   * @param {function} callback
   */
  getConnections(callback) {
    // This method is used by `even-better` (before we start platform).
    // It seems that the latest version of parent `good` doesn't use this anymore.
    if (this._server) {
      this._server.getConnections(callback);
    } else {
      callback(null, 0);
    }
  }

  /**
   * Binds Http/Https server to the LegacyPlatformProxifier.
   * @param {Server} server Server to bind to.
   */
  bind(server) {
    const oldServer = this._server;
    this._server = server;

    for (const [eventName, eventHandler] of this._eventHandlers) {
      oldServer && oldServer.removeListener(eventName, eventHandler);
      this._server.addListener(eventName, eventHandler);
    }
  }

  /**
   * Forwards request and response objects to the legacy platform.
   * This method is used whenever new platform doesn't know how to handle the request.
   * @param {IncomingMessage} request Native Node request object instance.
   * @param {ServerResponse} response Native Node response object instance.
   */
  proxy(request, response) {
    this._log.debug(
      `Request will be handled by proxy ${request.method}:${request.url}.`
    );
    this.emit('request', request, response);
  }
}
